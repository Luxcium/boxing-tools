PACKAGE: `https://www.npmjs.com/package/mapping-tools`

"Mapping Tools is a user-friendly npm package designed for JavaScript and TypeScript developers. It provides utility functions for working with data collections, allowing developers to apply transformations or validations to each item in a collection, either in serial or in parallel. The package supports advanced error handling and asynchronous code, making it suitable for a wide range of applications, including data processing and validation."

Installation:
To install Mapping Tools, use npm, yarn, or pnpm:

```shell
# npm
npm install mapping-tools
# yarn
yarn add mapping-tools
# pnpm
pnpm add mapping-tools
```

Usage Overview:
Mapping Tools provides 5 main functions: awaitedMapping, parallelMapping, serialMapping, generateMappingAsync, and generateMapping. These functions work with both promises and non-promises and support advanced error handling. The output is based on the Settled<TVal> type, which allows users to distinguish between successful and unsuccessful results.

Each function takes a collection of items and 4 optional delegate functions: transformFn, lookupFn, validateFn, and errLookupFn. The transformFn transforms each item, while lookupFn and validateFn can perform additional operations. The errLookupFn handles errors that may occur during processing.

Quick Start:
To use Mapping Tools, import it in your code like this:

```javascript
const mappingTools = require('mapping-tools');
// or
import * as mappingTools from 'mapping-tools';
```
Then, you can use the various functions provided by the library to generate, transform, and iterate over maps, as well as to perform asynchronous map generation.

Main Functions:
Mapping Tools provides 5 main functions: `awaitedMapping`, `parallelMapping`, `serialMapping`, `generateMappingAsync`, and `generateMapping`. These functions work with both promises and non-promises and support advanced error handling. The output is based on the `Settled<TVal>` type, which allows users to distinguish between successful and unsuccessful results.

`parallelMapping` is one of the main functions, which applies the provided callback functions to each item in the collection in parallel, and returns an array of promises that resolve to the transformed and validated items, represented as `Settled<R>` objects.

The function signature is:

```TypeScript
export function parallelMapping<T, R>(
  collection: Collection<T>,
  transformFn?: TransformFn<T, R> | null,
  lookupFn?: LookupFn<T, R> | null,
  validateFn?: ValidateFn<T, R> | null,
  errLookupFn?: ErrLookupFn | null
): Promise<Settled<R>>[];
```

`parallelMapping` takes an iterable of `Base<T>` or `PromiseLike<Base<T>>` and returns an array of `Promise<Settled<R>>`. The `TransformFn`, `LookupFn`, `ValidateFn`, and `ErrLookupFn` are optional delegate functions that can perform additional operations.

Note that `parallelMapping` is based on the `Array.prototype.map` method.

"serialMapping applies the provided callback functions to each item in the collection in series and returns an array of the transformed and validated items. It takes an iterable of Base<T> or PromiseLike<Base<T>> and returns a Promise<Array<Settled<R>>>. The function signature is:

```TypeScript
export async function serialMapping<T, R>(
  collection: DeferredCollection<T>,
  transformFn: TransformFn<T, R> | null = async value => value as any as R,
  lookupFn: LookupFn<T, R> | null = v => void v,
  validateFn: ValidateFn<T, R> | null = async v => void v,
  errLookupFn: ErrLookupFn | null = v => void v
): Promise<Settled<R>[]>
```

Note that it is based on the forOf loop."

"awaitedMapping applies the provided callback functions to each item in the collection, and returns a promise that resolves to an array of the transformed and validated items, represented as Settled<R> objects. It takes an iterable of Base<T> or PromiseLike<Base<T>> and returns a Promise<Array<Settled<R>>>. The function signature is:

```TypeScript
export async function awaitedMapping<T, R>(
  collection: DeferredCollection<T>,
  transformFn: TransformFn<T, R> | null = async value => value as any as R,
  lookupFn: LookupFn<T, R> | null = v => void v,
  validateFn: ValidateFn<T, R> | null = async v => void v,
  errLookupFn: ErrLookupFn | null = v => void v
): Promise<Settled<R>[]>;
```

Note that it is based on Promise.all($)."

`generateMapping` applies the provided callback functions to each item in the collection, and returns a generator that yields promises that resolve to the transformed and validated items, represented as `Settled<R>` objects. It is based on the Generator Protocol and takes an iterable of `Base<T>` or `PromiseLike<Base<T>>`. The function signature is:

```TypeScript
export function* generateMapping<T, R>(
  collection: Collection<T>,
  transformFn?: TransformFn<T, R> | null,
  lookupFn?: LookupFn<T, R> | null,
  validateFn?: ValidateFn<T, R> | null,
  errLookupFn?: ErrLookupFn | null
): Generator<Promise<Settled<R>>, void, unknown>;
```

Note that it is based on the Generator Protocol

`generateMappingAsync` is a function that applies the provided callback functions to each item in the collection, and returns an async generator that yields the transformed and validated items, represented as `Settled<R>` objects. It takes an iterable of `Base<T>` or `PromiseLike<Base<T>>` and returns an `AsyncGenerator<Settled<R>, void, unknown>`. The function signature is:

```TypeScript
export async function* generateMappingAsync<R, T>(
  collection: Collection<T>,
  transformFn: TransformFn<T, R> | null = async value => value as any as R,
  lookupFn: LookupFn<T, R> | null = v => void v,
  validateFn: ValidateFn<T, R> | null = async v => void v,
  errLookupFn: ErrLookupFn | null = v => void v
): AsyncGenerator<Settled<R>, void, unknown>;
```

Note that it is based on the AsyncGenerator Protocol.

"Mapping Tools provides 5 main functions with complex signatures:

- parallelMapping returns: Array<Promise<Settled<R>>>
- serialMapping returns: Promise<Array<Settled<R>>>
- awaitedMapping returns: Promise<Array<Settled<R>>>
- generateMapping returns: Generator<Promise<Settled<R>>, void, unknown>
- generateMappingAsync returns: AsyncGenerator<Settled<R>, void, unknown>

The functions take a collection of items and optional delegate functions: transformFn, lookupFn, validateFn, and errLookupFn. The collection can be an iterable or a combination of an iterable and a promise of an iterable. The delegate functions are applied to each item in the collection and take an item of type T as input and return a value of type R. The Base<T> type represents a resolved or rejected promise, or a value."
"Mapping Tools provides four main types of delegate functions that can be used as arguments to the main functions: `TransformFn`, `LookupFn`, `ValidateFn`, and `ErrLookupFn`. These delegates are responsible for carrying out the mapping, validation, and error handling processes. They can take null or undefined values that are replaced by default values.

`TransformFn` is used for the actual mapping process and expects that you will transform from input type T to returned type U. Proper type annotations are required if you return an unchanged value. The function signature is:

```TypeScript
export interface TransformFn<T, U = unknown> {
  (
    value: T,
    index: number,
    array: readonly (T | PromiseSettledResult<T>)[]
  ): Promise<U>;
}
```

`LookupFn` is used to acknowledge the transformed value U in an asynchronous manner. The return value must be void and must not have any internal side effects within the function. The function signature is:

```TypeScript
export interface LookupFn<S, U = unknown> {
  (
    value: U,
    index: number,
    array: readonly (S | Settled<S> | PromiseSettledResult<S>)[]
  ): OnlySideEffect;
}
```

`ValidateFn` is similar to the `LookupFn` delegate but is awaited within the function where it is executed. The return value must be a Promise<void>, and the only way to communicate with the main function is to throw a value or exception, which will be caught in the function and returned as a `SettledLeft`. The function signature is:

```TypeScript
export interface ValidateFn<S, U = unknown> {
  (
    value: U,
    index: number,
    array: readonly (S | PromiseSettledResult<S>)[]
  ): Promise<OnlySideEffect>;
}
```

`ErrLookupFn` is used to handle errors and is similar to the `LookupFn` delegate, but for rejections. It takes a `currentRejection` flag as its third argument, which indicates whether the error occurred during the current iteration or a previous iteration. The function signature is:

```TypeScript
export interface ErrLookupFn {
  (reason: any, index: number, currentRejection: boolean): OnlySideEffect;
}
```

The delegates are linked via parameters that can be accessed from the outside by providing a function of a certain type as an argument. The package allows you to alter the workflow in five different areas inside the specific mapping operation over each element. The interfaces define the signature of each delegate function and specify the types of the input and output parameters, allowing the consuming AI to correctly infer the types of the delegate functions and use them effectively."
